#!/usr/bin/env bash

set -eu

format=%d/%n%e
start_num=1
increment=1

me=${0##*/}
usage="Rename files as a sequence of numbers.

Usage:
    $me [OPTIONS] FILE...

Options:
    -f           use -f instead of -i in the generated mv commands
    -w           equalize width by padding with leading zeroes
    -W NUMBER    pad each number to an exact width with leading zeroes
    -s NUMBER    starting number (default: $start_num)
    -i NUMBER    increment (default: $increment)
    -F FORMAT    file path format (default: $format)

The following placeholders are recognized in FORMAT:
    %n           number of FILE (required)
    %N           total number of files
    %d           directory of FILE
    %b           basename of FILE
    %e           extension of FILE
"

usage() {
    printf "%s\n" "$usage"
    exit 0
}

die() {
    printf "%s: line %s: %s\n" "$0" "${BASH_LINENO[0]}" "$*" >&2
    exit 1
}

extname() {
    awk 'match($0, /(\.[[:alnum:]]+)+$/) { print substr($0, RSTART, RLENGTH) }' <<<"$1"
}

declare -a mkbr_options

auto_width=0

while getopts ":F:s:i:W:wfh" option; do
    case $option in
    F) format=$OPTARG ;;
    s) start_num=$OPTARG ;;
    i) increment=$OPTARG ;;
    W) width=$OPTARG ;;
    w) auto_width=1 ;;
    f) mkbr_options+=(-f) ;;
    h) usage ;;
    *) die "invalid option '$OPTARG'" ;;
    esac
done && shift $((OPTIND - 1))

if [[ $format != *%n* ]]; then
    die "format does not contain '%n'"
fi

if [[ -v width && $width == *[!0-9]* ]]; then
    die "width must be a positive integer"
fi

if [[ $start_num == *[!0-9]* ]]; then
    die "start number must be a positive integer"
fi

if [[ $increment == *[!0-9]* ]]; then
    die "increment must be a positive integer"
fi

temp_dir=$(mktemp -d -t "${me}.XXXXXXXXXX")
printf -v cleanup "rm -rf %q" "$temp_dir"
trap "$cleanup" INT TERM EXIT

src_list=$temp_dir/src
dst_list=$temp_dir/dst

if (($# == 0)); then
    cat >"$src_list"
else
    printf "%s\n" "$@" >"$src_list"
fi

num=$start_num
format=${format/\%N/$#}
num_lines=$(wc -l <"$src_list")
end_num=$((start_num + num_lines - 1))

if ((auto_width)); then
    width=${#end_num}
fi

while read -r src; do
    if [[ -v width ]]; then
        printf -v num_padded "%0${width}d" "$num"
    else
        num_padded=$num
    fi

    src=$1
    shift

    dir=$(dirname "$src")
    ext=$(extname "$src")
    base=$(basename "$src" "$ext")

    dst=$format
    dst=${dst/\%n/$num_padded}
    dst=${dst/\%d/$dir}
    dst=${dst/\%b/$base}
    dst=${dst/\%e/$ext}

    echo "$dst" >>"$dst_list"

    num=$((num + increment))
done <"$src_list"

mkbr "${mkbr_options[@]}" "$src_list" "$dst_list"

#!/usr/bin/env bash

set -eu
shopt -s nullglob

cache_dir=${XDG_CACHE_HOME:-$HOME/.cache}/yank

me=${0##*/}
usage="Move text around using file-based registers.

Usage:
    $me [OPTIONS] ACTION [REGISTER...]

Options:
    -a              perform action on all existing registers
                    (includes 'default', which is always first)

    -C DIRECTORY    directory in which to store registers
                    (default: $cache_dir)

Arguments:
    ACTION          perform action on lines of a register

    REGISTER        limit action to this register
                    (default: 'default')

Actions:
    list            print register names to stdout
    set             set register contents from stdin
    add             add lines from stdin to register
    edit            open register in EDITOR
    print           print register to stdout
    clear           clear register contents
"

usage() {
    printf "%s\n" "$usage"
    exit 0
}

die() {
    printf "%s: line %s: %s\n" "$0" "${BASH_LINENO[0]}" "$1" >&2
    exit "${2:-1}"
}

list_register_files() {
    if [[ -d $cache_dir ]]; then
        # Always list default register first, if it exists.
        if [[ -r $cache_dir/default ]]; then
            printf "%s/default\n" "$cache_dir"
        fi
        # Skip default register and sort others naturally.
        find "$cache_dir" -type f | grep -v "/default$" | sort
    fi
}

do_add() {
    mkdir -p "$cache_dir"
    tee -a "${register_files[@]}" >/dev/null
}

do_set() {
    do_clear
    do_add
}

do_edit() {
    exec ${EDITOR:-vim} "${register_files[@]}"
}

do_list() {
    list_register_files | xargs -I{} basename {}
}

do_print() {
    local register_file
    for register_file in "${register_files[@]}"; do
        if [[ -r $register_file ]]; then
            cat "$register_file"
        fi
    done
}

do_clear() {
    rm -f "${register_files[@]}"
}

select_all=0
register_files=()

while getopts ":aC:h" option; do
    case $option in
    a) select_all=1 ;;
    C) cache_dir=$OPTARG ;;
    h) usage ;;
    *) die "invalid option -- $OPTARG" ;;
    esac
done && shift $((OPTIND - 1))

action=${1:?missing action}
shift

if ((select_all)); then
    readarray -t register_files < <(list_register_files)
elif (($# > 0)); then
    for register_name in "$@"; do
        register_files+=("$cache_dir/$register_name")
    done
else
    register_files=("$cache_dir"/default)
fi

case $action in
add | set | edit | list | print | clear) ;;
*) die "invalid action -- $action" ;;
esac

do_"$action"

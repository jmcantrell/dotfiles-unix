#!/usr/bin/env bash

# Create a snapshot of a disk image.
# Usage: qemu-snapshot NAME [BASE]

set -e

name=${1:?missing system name}
base=$2

images=$HOME/.qemu
image=$images/$name.cow
snapshots=$images/snapshots
size=${size:-50G}
format=qcow2

fstype() {
    local fstype
    local here=${1:-$PWD}

    # Starting at $here, look for the closest mount point,
    # and if found, return the filesystem type.
    while [[ ! $fstype ]]; do
        fstype=$(mount | grep " $here " | cut -d' ' -f5)
        here=$(dirname "$here")
    done

    echo "$fstype"
}

snapshot_names() {
    while read -r snapshot; do
        basename "$snapshot"
    done < <(find "$snapshots" -name "${name}_*")
}

mkdir -p "$images"

# disable btrfs copy-on-write for vm dir
[[ $(fstype "$images") == btrfs ]] && chattr +C "$images"

# if the string "menu" is given as the base,
# then use a menu to select the base image
if [[ $base == menu ]]; then
    echo "Base snapshot on which image?" >&2
    select snapshot in $(snapshot_names); do
        base=$snapshots/$snapshot
        break
    done
fi

# if no base image given, use the current one
if [[ ! $base && -f $image ]]; then
    base=$(realpath "$image")
fi

# if some base was given,
# but it's not a file, try to build it
if [[ $base && ! -f $base ]]; then
    base=$snapshots/${base%%.cow}.cow
fi

if [[ $base && ! -f $base ]]; then
    echo "Image $base does not exist" >&2
    exit 1
fi

mkdir -p "$snapshots"

snapshot=$snapshots/${name}_$(date +%s).cow

if [[ $base ]]; then
    qemu-img create -f "$format" \
        -o "backing_file=$base,backing_fmt=$format" \
        "$snapshot"
else
    # initial image creation
    qemu-img create -f "$format" "$snapshot" "$size"
fi

ln -sfvT "$snapshot" "$image"

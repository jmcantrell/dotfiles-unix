#!/usr/bin/env bash

set -e

me=${0##*/}

usage="Safely manage a queue of items.
Usage: $me -h       # show this help message
       $me -f FILE  # use FILE as queue file
       $me -a ITEM  # add ITEM to queue
       $me -l       # list items in queue (this is the default)
       $me -p       # pop the next item and print it
       $me -c       # clear the queue
"

die() {
    echo "$me: $*" >&2
    exit 1
}

action="list"
unset OPTIND queue item
while getopts ":hf:a:lpc" option; do
    case $option in
    f) queue=$OPTARG ;;
    a)
        action="add"
        item=$OPTARG
        ;;
    p) action="pop" ;;
    l) action="list" ;;
    c) action="clear" ;;

    h)
        echo "$usage" >&2
        exit 0
        ;;

    *) die "invalid option '$option'" ;;
    esac
done && shift $((OPTIND - 1))

# Ensure this invocation has exclusive access to the queue file.
# If it doesn't, wait until it does.

if [[ "$FLOCKER" != "$0" ]]; then
    [[ $queue ]] || die "no queue file provided"

    export FLOCKER=$0
    export QUEUE=$queue
    export ACTION=$action
    export ITEM=$item
    exec flock "$queue" "$0" "$@"
fi

unset FLOCKER

require() {
    for name in "$@"; do
        [[ ${!name} ]] || die "$name is not set"
    done
}

queue_list() {
    require QUEUE
    grep -v -E "$@" '^\s*(#|$)' "$QUEUE"
}

queue_add() {
    require ITEM QUEUE
    echo "$ITEM" >>"$QUEUE"
}

queue_pop() {
    require QUEUE

    # Get the first line in the queue that isn't blank or commented out.
    # The line number is included so that it can be referenced directly with sed.
    next=$(queue_list -m1 -n)

    # As soon as the queue is empty, the grep command will fail and this script will
    # exit with a non-zero status.

    line_num=${next%%:*}
    line=${next#*:}

    # Comment out the line that was just retrieved.
    sed -E -i "${line_num}s/^\s*/# /" "$QUEUE"

    echo "$line"
}

queue_clear() {
    require QUEUE
    sed -E -i "/^\s*[^#]/s/^\s*/# /" "$QUEUE"
}

require ACTION
queue_$ACTION

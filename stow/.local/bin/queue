#!/usr/bin/env bash

set -e

me=${0##*/}
usage="Safely manage a queue of items.

Usage: $me [-h] [-lpc] -f FILE [-a ITEM]

Options:
    -h         show this help message
    -f FILE    use FILE as queue storage (required)
    -a ITEM    add ITEM to queue
    -l         list items in queue (this is the default)
    -p         pop the next item and print it
    -c         clear the queue
"

usage() {
    echo "$usage" >&2
    exit 0
}

die() {
    echo "$me: $*" >&2
    exit 1
}

unset OPTIND OPTARG
while getopts ":hf:plca:" option; do
    case $option in
    h) usage ;;

    f) queue=$OPTARG ;;
    p) action="pop" ;;
    l) action="list" ;;
    c) action="clear" ;;
    a)
        action="add"
        item=$OPTARG
        ;;

    *) die "invalid option '$option'" ;;
    esac
done && shift $((OPTIND - 1))

# Ensure this invocation has exclusive access to the queue file.
# If it doesn't, wait until it does.

if [[ "$FLOCKER" != "$0" ]]; then
    [[ $queue ]] || die "no queue file provided"

    export FLOCKER=$0
    export QUEUE=$queue
    export ACTION=${action:-list}
    export ITEM=$item
    exec flock "$queue" "$0" "$@"
fi

unset FLOCKER

require() {
    for name in "$@"; do
        [[ ${!name} ]] || die "$name is not set"
    done
}

queue_list() {
    require QUEUE
    grep -v -E "$@" '^\s*(#|$)' "$QUEUE"
}

queue_add() {
    require ITEM QUEUE
    echo "$ITEM" >>"$QUEUE"
}

queue_pop() {
    require QUEUE

    # Get the first line in the queue that isn't blank or commented out.
    # The line number is included so that it can be referenced directly with sed.
    next=$(queue_list -m1 -n)

    # As soon as the queue is empty, the grep command will fail and this script will
    # exit with a non-zero status.

    line_num=${next%%:*}
    line=${next#*:}

    # Comment out the line that was just retrieved.
    sed -E -i "${line_num}s/^\s*/# /" "$QUEUE"

    echo "$line"
}

queue_clear() {
    require QUEUE
    sed -E -i "/^\s*[^#]/s/^\s*/# /" "$QUEUE"
}

require ACTION
queue_$ACTION
